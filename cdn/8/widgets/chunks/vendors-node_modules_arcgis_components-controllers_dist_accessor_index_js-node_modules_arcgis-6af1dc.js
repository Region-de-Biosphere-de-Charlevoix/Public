"use strict";
(self["webpackChunkexb_client"] = self["webpackChunkexb_client"] || []).push([["vendors-node_modules_arcgis_components-controllers_dist_accessor_index_js-node_modules_arcgis-6af1dc"],{

/***/ "./node_modules/@arcgis/components-controllers/dist/accessor/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@arcgis/components-controllers/dist/accessor/index.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AccessorController: () => (/* binding */ AccessorController),
/* harmony export */   accessorSupport: () => (/* binding */ accessorSupport),
/* harmony export */   makeAccessorController: () => (/* binding */ makeAccessorController),
/* harmony export */   reEmitEvent: () => (/* binding */ reEmitEvent)
/* harmony export */ });
/* harmony import */ var _chunk_PP2BAVRW_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../chunk-PP2BAVRW.js */ "./node_modules/@arcgis/components-controllers/dist/chunk-PP2BAVRW.js");
/* harmony import */ var _chunk_XKVBN44N_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../chunk-XKVBN44N.js */ "./node_modules/@arcgis/components-controllers/dist/chunk-XKVBN44N.js");
/* harmony import */ var _arcgis_core_adapter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @arcgis/core-adapter */ "@arcgis/core-adapter");
/* harmony import */ var _arcgis_components_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @arcgis/components-utils */ "./node_modules/@arcgis/components-utils/dist/index.js");



// src/accessor/utils.ts

var reactiveUtils;
async function loadReactiveUtils() {
  reactiveUtils ?? (reactiveUtils = (0,_arcgis_core_adapter__WEBPACK_IMPORTED_MODULE_2__.importCoreReactiveUtils)());
  return await reactiveUtils;
}

// src/accessor/useAccessor.ts

var makeAccessorController = (loadAccessor, _options) => (component, options) => proxy(component, loadAccessor, options);
var AccessorController = class extends _chunk_PP2BAVRW_js__WEBPACK_IMPORTED_MODULE_0__.GenericController {
  constructor(component, _loadAccessor, _options) {
    super(component);
    this._loadAccessor = _loadAccessor;
    this._options = _options;
    // A mapping from bound component's "prop" name to Accessor instance's "property"
    this._watchedProperties = /* @__PURE__ */ new Map();
    this._isBinding = { value: true };
    this.setProvisionalExports(
      accessorSupport.makeGetterProxy(
        component,
        this._watchedProperties,
        this._isBinding,
        this.constructor.allowedPropNameMismatches
      )
    );
    (0,_chunk_PP2BAVRW_js__WEBPACK_IMPORTED_MODULE_0__.trackPropKey)(
      component,
      (resolved) => {
        if (resolved) {
          this._instancePropName = resolved;
        }
      },
      this.exports
    );
  }
  hostConnected() {
    this._isBinding.value = false;
  }
  async hostLoad() {
    this.reactiveUtils = await loadReactiveUtils();
    const component = this.component;
    const parameters = this._gatherParameters();
    const finalParameters = this._options?.editConstructorProperties?.call(component, parameters) ?? parameters;
    const awaitedParameters = finalParameters instanceof Promise ? await finalParameters : finalParameters;
    const genericComponent = component;
    const existingInstance = typeof this._instancePropName === "string" ? genericComponent[this._instancePropName] : void 0;
    const hasInstance = existingInstance != null && existingInstance !== this.exports;
    if (hasInstance) {
      this._instance = existingInstance;
      existingInstance.set(awaitedParameters);
    } else {
      this._instance = await this._createInstance(awaitedParameters);
    }
    if (component.manager.destroyed) {
      return;
    }
    accessorSupport.watchComponentUpdates(this, this._instance, this._watchedProperties);
    accessorSupport.watchAccessorUpdates(this, this._instance, this._watchedProperties);
    this.exports = this._instance;
  }
  _gatherParameters() {
    const data = Object.fromEntries(
      Array.from(
        this._watchedProperties,
        ([prop, property]) => [property, this.component[prop]]
      ).filter(([, value]) => value !== void 0)
    );
    const props =  true && (0,_arcgis_components_utils__WEBPACK_IMPORTED_MODULE_3__.isEsriInternalEnv)() ? filterWatchedProperties?.(this, data) ?? data : data;
    return props;
  }
  async _createInstance(parameters) {
    if (this._isAccessorConstructor(this._loadAccessor)) {
      return new this._loadAccessor(parameters);
    } else {
      return await this._loadAccessor(parameters);
    }
  }
  _isAccessorConstructor(loader) {
    return "prototype" in loader && "declaredClass" in loader.prototype;
  }
  hostDestroy() {
    if (this._instance) {
      this._instance.destroy();
    }
  }
  async reCreate() {
    this.hostDestroy();
    await this.hostLoad();
  }
};
var proxy = (0,_chunk_PP2BAVRW_js__WEBPACK_IMPORTED_MODULE_0__.proxyExports)(AccessorController);
var accessorSupport = {
  makeGetterProxy: (component, watchedProperties, isBinding, allowedPropNameMismatches) => new Proxy(
    {},
    {
      /*
       * Without this, makeProvisionalValue() will throw on accessing
       * non-existent prop
       */
      has: (target, prop) => typeof prop === "string" || prop in target,
      get: (target, prop) => {
        const value = Reflect.get(target, prop);
        if (typeof prop === "symbol" || prop in Promise.prototype) {
          return value;
        }
        const hasProp = prop in target;
        const doBinding = isBinding?.value ?? true;
        if (hasProp || !doBinding) {
          return value;
        }
        if (watchedProperties.has(prop)) {
          if ( true && (0,_arcgis_components_utils__WEBPACK_IMPORTED_MODULE_3__.isEsriInternalEnv)() && !component.manager.isLit) {
            throw new Error(
              `Tried to bind "${prop.toString()}" prop twice. This might also happen if you are trying to access the accessor instance before ${component.manager.isLit ? "load" : "componentWillLoad"}()`
            );
          }
          return;
        }
        return (0,_chunk_PP2BAVRW_js__WEBPACK_IMPORTED_MODULE_0__.trackKey)(
          component,
          (resolved) => {
            if ( true && (0,_arcgis_components_utils__WEBPACK_IMPORTED_MODULE_3__.isEsriInternalEnv)()) {
              if (resolved === void 0) {
                if (component.manager.isLit) {
                  return;
                }
                throw new Error(
                  `Unable to resolve what property is "${prop.toString()}" being bound too. Check documentation for useAccessor to ensure proper usage. Make sure you are not trying to access the accessor instance before ${component.manager.isLit ? "load" : "componentWillLoad"}()`
                );
              }
              const isFlippingBoolean = resolved.key.toLowerCase().includes("disable");
              const collidesWithNativeProp = prop in HTMLElement.prototype;
              const collidesWithCustomProp = allowedPropNameMismatches?.has(prop) === true;
              if (resolved.key !== prop && !collidesWithNativeProp && !collidesWithCustomProp && !isFlippingBoolean) {
                throw new Error(
                  `Tried to bind "${resolved?.key}" property to "${prop.toString()}" - property names must match`
                );
              }
              if (!resolved.isReactive) {
                throw new Error(
                  component.manager.isLit ? `For two-way binding with Accessor to work, the property on your component must have @property() or @state() decorator. "${prop.toString()}" has neither` : `For two-way binding with Accessor to work, the property on your component must have @Prop() or @State() decorator. "${prop.toString()}" has neither`
                );
              }
            }
            if (resolved !== void 0) {
              watchedProperties.set(resolved.key, prop);
            }
          },
          value
        );
      }
    }
  ),
  // Update Accessor on component prop change
  watchComponentUpdates(controller, instance, watchedProperties) {
    function getter(_value, propName) {
      const propertyName = watchedProperties.get(propName);
      const value = instance[propertyName];
      const flipBoolean = typeof value === "boolean" && propertyName !== propName && propName.toLowerCase().includes("disable");
      return flipBoolean ? !value : value;
    }
    const setter = (newValue, _oldValue, propName) => {
      const propertyName = watchedProperties.get(propName);
      const value = instance[propertyName];
      const flipBoolean = typeof value === "boolean" && propertyName !== propName && propName.toLowerCase().includes("disable");
      const currentValue = flipBoolean ? !value : component.manager.isLit ? value ?? void 0 : value;
      if (currentValue === newValue) {
        return newValue;
      }
      instance[propertyName] = flipBoolean ? !newValue : newValue;
      const finalValue = instance[propertyName];
      return flipBoolean ? !finalValue : finalValue;
    };
    const component = controller.component;
    const internals = component.manager.internals;
    watchedProperties.forEach((_propName, propertyName) => {
      internals.accessorGetter[propertyName] = getter;
      internals.accessorSetter[propertyName] = setter;
    });
  },
  // Update component on Accessor prop change
  watchAccessorUpdates(controller, instance, watchedProperties) {
    const { component } = controller;
    const genericComponent = component;
    const genericInstance = instance;
    const readonlyProps = findReadOnlyAccessorProps(instance);
    if ( true && (0,_arcgis_components_utils__WEBPACK_IMPORTED_MODULE_3__.isEsriInternalEnv)()) {
      setReadonlyProps?.(controller, readonlyProps);
    }
    (0,_chunk_PP2BAVRW_js__WEBPACK_IMPORTED_MODULE_0__.bypassGetter)(
      () => (
        // Careful: Map's forEach callback arguments are (value, key), not (key, value)
        watchedProperties.forEach((propertyName, propName) => {
          if ( true && (0,_arcgis_components_utils__WEBPACK_IMPORTED_MODULE_3__.isEsriInternalEnv)() && !(propertyName in instance)) {
            throw new Error(`"${propertyName}" does not exist on the accessor instance`);
          }
          if (readonlyProps.has(propertyName)) {
            return;
          }
          const domValue = genericComponent[propName];
          let modelValue = genericInstance[propertyName];
          if (component.manager.isLit) {
            modelValue ?? (modelValue = void 0);
          }
          const flipBoolean = typeof domValue === "boolean" && propertyName !== propName && propName.toLowerCase().includes("disable");
          const resolvedDomValue = flipBoolean ? !domValue : domValue;
          if (resolvedDomValue != null && modelValue !== resolvedDomValue) {
            genericInstance[propertyName] = resolvedDomValue;
          }
        })
      )
    );
    controller.onLifecycle(() => {
      if (instance.destroyed) {
        return;
      }
      return Array.from(
        watchedProperties,
        ([propName, propertyName]) => controller.reactiveUtils.watch(
          () => genericInstance[propertyName],
          () => {
            const newValue = genericInstance[propertyName];
            const flipBoolean = typeof newValue === "boolean" && propertyName !== propName && propName.toLowerCase().includes("disable");
            const resolvedNewValue = flipBoolean ? !newValue : newValue;
            (0,_chunk_PP2BAVRW_js__WEBPACK_IMPORTED_MODULE_0__.bypassSetter)(() => {
              genericComponent[propName] = resolvedNewValue;
            });
          },
          { initial: true }
        )
      );
    });
  },
  // REFACTOR: remove this once Stencil is no longer supported
  reEmitAccessorEvents(controller, instance, reactiveUtils2, prefix) {
    const isEvented = "on" in instance && typeof instance.on === "function";
    if (!isEvented) {
      return;
    }
    const toListen = Object.entries(controller.component).map(([key, unknown]) => {
      const value = unknown;
      if (!key.startsWith(prefix) || key === prefix || typeof value !== "object" || value === null || !("emit" in value) || typeof value.emit !== "function") {
        return void 0;
      }
      const emit = value.emit;
      const trimmedEventName = key.slice(prefix.length);
      const camelCaseEventName = (0,_arcgis_components_utils__WEBPACK_IMPORTED_MODULE_3__.camelToKebab)(trimmedEventName);
      const eventName = camelCaseEventName.toLowerCase();
      return [eventName, emit];
    }).filter(_arcgis_components_utils__WEBPACK_IMPORTED_MODULE_3__.isNotUndefined);
    if (toListen.length === 0) {
      return;
    }
    const eventTarget = instance;
    const getEventTarget = () => eventTarget;
    controller.onLifecycle(() => {
      if (instance.destroyed) {
        return;
      }
      return toListen.map(([eventName, emit]) => reactiveUtils2.on(getEventTarget, eventName, emit));
    });
  },
  async reCreate(instance, component) {
    const accessorController = component.manager.useRefSync(instance);
    if (accessorController === void 0) {
      if (true) {
        console.error("Unable to resolve the useAccessor controller from the provided value");
      }
      return;
    }
    await accessorController.reCreate();
  }
};
function findReadOnlyAccessorProps(instance) {
  const accessor = instance;
  const properties = Object.entries(accessor.__accessor__?.metadata ?? {});
  return new Set(
    properties.filter(([_property, descriptor]) => descriptor?.readOnly === true).map(([property]) => property)
  );
}
var setReadonlyProps =  true && (0,_arcgis_components_utils__WEBPACK_IMPORTED_MODULE_3__.isEsriInternalEnv)() ? (controller, properties) => {
  (0,_chunk_PP2BAVRW_js__WEBPACK_IMPORTED_MODULE_0__.devOnlySetPersistentControllerData)?.(controller, properties);
} : void 0;
var filterWatchedProperties =  true && (0,_arcgis_components_utils__WEBPACK_IMPORTED_MODULE_3__.isEsriInternalEnv)() ? (controller, data) => {
  const readonlyProperties = (0,_chunk_PP2BAVRW_js__WEBPACK_IMPORTED_MODULE_0__.devOnlyGetPersistentControllerData)?.(controller);
  if (readonlyProperties instanceof Set) {
    return Object.fromEntries(Object.entries(data).filter(([key]) => !readonlyProperties.has(key)));
  }
  return data;
} : void 0;

// src/accessor/reEmitEvent.ts

function reEmitEvent(getEventedAccessor, eventName) {
  const component = (0,_chunk_PP2BAVRW_js__WEBPACK_IMPORTED_MODULE_0__.retrieveComponent)();
  if ( true && (0,_arcgis_components_utils__WEBPACK_IMPORTED_MODULE_3__.isEsriInternalEnv)() && !component.manager.isLit) {
    throw new Error(
      "reEmitEvent is only supported in Lumina components. Consult documentation for equivalent Stencil pattern."
    );
  }
  const manager = component.manager;
  const reactiveUtils2 = loadReactiveUtils();
  manager.onLoaded(() => {
    void reactiveUtils2.then(
      (reactiveUtils3) => manager.onLifecycle(() => reactiveUtils3.on(getEventedAccessor, eventName, emitter.emit))
    );
  });
  const emitter = component.constructor.$createEvent();
  if ( true && (0,_arcgis_components_utils__WEBPACK_IMPORTED_MODULE_3__.isEsriInternalEnv)()) {
    if (typeof emitter !== "object" || emitter === null || !("emit" in emitter) || typeof emitter.emit !== "function") {
      throw new Error(`Expected to find $createEvent static property on Lumina's LitElement`);
    }
  }
  return emitter;
}



/***/ }),

/***/ "./node_modules/@arcgis/map-components/dist/chunks/component-utils.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@arcgis/map-components/dist/chunks/component-utils.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ p),
/* harmony export */   b: () => (/* binding */ P),
/* harmony export */   c: () => (/* binding */ H),
/* harmony export */   d: () => (/* binding */ L),
/* harmony export */   e: () => (/* binding */ O),
/* harmony export */   f: () => (/* binding */ x),
/* harmony export */   i: () => (/* binding */ N),
/* harmony export */   p: () => (/* binding */ u),
/* harmony export */   r: () => (/* binding */ S)
/* harmony export */ });
/*! All material copyright Esri, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
v4.32.1 */
function P(e, i) {
  Array.isArray(i) ? e._watchHandles = [...e._watchHandles, ...i] : e._watchHandles.push(i);
}
function p(e) {
  e.el.childElem && (e.el.childElem.ownedBy = e.el);
  const i = h(e);
  if (!i) {
    const t = y(e.referenceElement);
    if (!t) {
      g(e);
      return;
    }
    return f(t, e, !0), t;
  }
  return w(i, e.el.parent) || (e.el.parent = i, i.tagName.toLowerCase() === "arcgis-expand" ? v(i, e) : i.tagName.toLowerCase() === "arcgis-placement" ? C(i, e) : f(i, e, !1)), i;
}
function h({ el: e }) {
  for (let i = e.parentElement; i; i = i?.parentElement ?? null) {
    if (c.has(i.tagName.toLowerCase()))
      return i;
    if ("ownedBy" in i && i.ownedBy instanceof HTMLElement && c.has(i.ownedBy.tagName.toLowerCase()))
      return i.ownedBy;
  }
}
const c = /* @__PURE__ */ new Set([
  "arcgis-map",
  "arcgis-scene",
  "arcgis-link-chart",
  "arcgis-expand",
  "arcgis-placement"
]);
function w(e, i) {
  if (e !== i)
    return !1;
  const t = e.tagName.toLowerCase();
  return t === "arcgis-expand" || t === "arcgis-placement";
}
function l(e, i, t = "arcgisReady") {
  const r = e;
  if (typeof r.view?.ready == "boolean")
    i(r.view);
  else {
    let s = function(d) {
      d.target === e && (l(e, i, t), e.removeEventListener(t, s));
    };
    e.addEventListener(t, s);
  }
}
const v = (e, i) => l(e, (t) => {
  i.el.childElem && e.content != null && e.content.append(i.el.childElem), e.expandIcon = i.icon || i.widget?.icon || e.expandIcon, i.position = e.position, i.el.view = t;
}), C = (e, i) => l(e, (t) => {
  i.el.childElem && i.el.append(i.el.childElem), i.position = e.position, i.el.view = t;
}), f = (e, i, t) => l(
  e,
  (r) => {
    t ? g(i) : i.el.childElem && E(e, i), i.el.view = r;
  },
  "arcgisViewReadyChange"
);
function E(e, i) {
  const t = i.el.childElem ?? i.el, r = [...e.children], s = {};
  for (const a of r) {
    const n = a.getAttribute("position") ?? "manual";
    s[n] ??= [], s[n].push({ child: a, position: n, index: r.indexOf(a) });
  }
  const d = s[i.position ?? "manual"]?.findIndex(({ child: a }) => a === i.el), o = e.view.ui;
  o.remove(t), o.add(t, { position: i.position, index: d });
}
function L(e) {
  let i = !1, t = e.el.view;
  const r = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(e.el), "view") ?? {
    get: () => t,
    set: (s) => t = s
  };
  Object.defineProperty(e.el, "view", {
    get: r.get.bind(e.el),
    set: (s) => {
      r.set.call(e.el, s), s && !i && (i = !0, e.arcgisReady.emit());
    },
    configurable: !0,
    enumerable: !0
  }), t && (e.el.view = t);
}
function x(e) {
  return e == null || e === "";
}
function H(e, i) {
  return i != null && e?.position === i.position && e?.heading === i.heading && e?.tilt === i.tilt && e?.fov === i.fov;
}
function N(e, i) {
  return i === void 0 || e?.targetGeometry !== i?.targetGeometry || e?.rotation !== i?.rotation || e?.scale !== i?.scale;
}
function O(e, i) {
  return u(i?.center, e);
}
function u(e, i) {
  if (typeof i == "string")
    return u(e, i.split(",").map(Number));
  if (!e)
    return i;
  if (Array.isArray(i)) {
    const t = i[0], r = i[1], s = i.length > 2 ? i[2] : void 0;
    if (t !== e.longitude || r !== e.latitude || s !== e.z)
      return i;
  } else if (i && !e?.equals(i))
    return i;
}
async function S(e, i) {
  i != null && (typeof i == "string" ? e.el.view = await b(i) : e.widget && (e.el.view = i.view));
}
async function b(e) {
  const i = y(e);
  return await new Promise((t) => {
    typeof i?.view?.ready == "boolean" ? t(i.view) : i && i.addEventListener("arcgisViewReadyChange", () => t(i.view), { once: !0 });
  });
}
function g(e) {
  e.el.childElem && (e.el.shadowRoot ?? e.el).append(e.el.childElem);
}
function y(e) {
  return typeof e != "string" ? e ?? void 0 : (e.includes("#") || e.includes(".") || e.includes("[") ? void 0 : document.querySelector(`#${e}`)) ?? document.querySelector(e) ?? void 0;
}



/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0cy9jaHVua3MvdmVuZG9ycy1ub2RlX21vZHVsZXNfYXJjZ2lzX2NvbXBvbmVudHMtY29udHJvbGxlcnNfZGlzdF9hY2Nlc3Nvcl9pbmRleF9qcy1ub2RlX21vZHVsZXNfYXJjZ2lzLTZhZjFkYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVU4QjtBQUNBOztBQUU5QjtBQUMrRDtBQUMvRDtBQUNBO0FBQ0Esb0NBQW9DLDZFQUF1QjtBQUMzRDtBQUNBOztBQUVBO0FBQzJGO0FBQzNGO0FBQ0EsdUNBQXVDLGlFQUFpQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0VBQVk7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsS0FBcUMsSUFBSSwyRUFBaUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0VBQVk7QUFDeEI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxLQUFxQyxJQUFJLDJFQUFpQjtBQUN4RTtBQUNBLGdD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0Q0FBNEM7QUFDekU7QUFDQSxvREFBb0QsVUFBVTtBQUM5RCwwQkFBMEIsZ0NBQWdDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUhBQXlILFVBQVU7QUFDbkksR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwySUFBMkksRUFBRTtBQUM3STtBQVdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhiLWNsaWVudC8uL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2NvbXBvbmVudHMtY29udHJvbGxlcnMvZGlzdC9hY2Nlc3Nvci9pbmRleC5qcyIsIndlYnBhY2s6Ly9leGItY2xpZW50Ly4vbm9kZV9tb2R1bGVzL0BhcmNnaXMvbWFwLWNvbXBvbmVudHMvZGlzdC9jaHVua3MvY29tcG9uZW50LXV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEdlbmVyaWNDb250cm9sbGVyLFxuICBieXBhc3NHZXR0ZXIsXG4gIGJ5cGFzc1NldHRlcixcbiAgZGV2T25seUdldFBlcnNpc3RlbnRDb250cm9sbGVyRGF0YSxcbiAgZGV2T25seVNldFBlcnNpc3RlbnRDb250cm9sbGVyRGF0YSxcbiAgcHJveHlFeHBvcnRzLFxuICByZXRyaWV2ZUNvbXBvbmVudCxcbiAgdHJhY2tLZXksXG4gIHRyYWNrUHJvcEtleVxufSBmcm9tIFwiLi4vY2h1bmstUFAyQkFWUlcuanNcIjtcbmltcG9ydCBcIi4uL2NodW5rLVhLVkJONDROLmpzXCI7XG5cbi8vIHNyYy9hY2Nlc3Nvci91dGlscy50c1xuaW1wb3J0IHsgaW1wb3J0Q29yZVJlYWN0aXZlVXRpbHMgfSBmcm9tIFwiQGFyY2dpcy9jb3JlLWFkYXB0ZXJcIjtcbnZhciByZWFjdGl2ZVV0aWxzO1xuYXN5bmMgZnVuY3Rpb24gbG9hZFJlYWN0aXZlVXRpbHMoKSB7XG4gIHJlYWN0aXZlVXRpbHMgPz8gKHJlYWN0aXZlVXRpbHMgPSBpbXBvcnRDb3JlUmVhY3RpdmVVdGlscygpKTtcbiAgcmV0dXJuIGF3YWl0IHJlYWN0aXZlVXRpbHM7XG59XG5cbi8vIHNyYy9hY2Nlc3Nvci91c2VBY2Nlc3Nvci50c1xuaW1wb3J0IHsgY2FtZWxUb0tlYmFiLCBpc0VzcmlJbnRlcm5hbEVudiwgaXNOb3RVbmRlZmluZWQgfSBmcm9tIFwiQGFyY2dpcy9jb21wb25lbnRzLXV0aWxzXCI7XG52YXIgbWFrZUFjY2Vzc29yQ29udHJvbGxlciA9IChsb2FkQWNjZXNzb3IsIF9vcHRpb25zKSA9PiAoY29tcG9uZW50LCBvcHRpb25zKSA9PiBwcm94eShjb21wb25lbnQsIGxvYWRBY2Nlc3Nvciwgb3B0aW9ucyk7XG52YXIgQWNjZXNzb3JDb250cm9sbGVyID0gY2xhc3MgZXh0ZW5kcyBHZW5lcmljQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGNvbXBvbmVudCwgX2xvYWRBY2Nlc3NvciwgX29wdGlvbnMpIHtcbiAgICBzdXBlcihjb21wb25lbnQpO1xuICAgIHRoaXMuX2xvYWRBY2Nlc3NvciA9IF9sb2FkQWNjZXNzb3I7XG4gICAgdGhpcy5fb3B0aW9ucyA9IF9vcHRpb25zO1xuICAgIC8vIEEgbWFwcGluZyBmcm9tIGJvdW5kIGNvbXBvbmVudCdzIFwicHJvcFwiIG5hbWUgdG8gQWNjZXNzb3IgaW5zdGFuY2UncyBcInByb3BlcnR5XCJcbiAgICB0aGlzLl93YXRjaGVkUHJvcGVydGllcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5faXNCaW5kaW5nID0geyB2YWx1ZTogdHJ1ZSB9O1xuICAgIHRoaXMuc2V0UHJvdmlzaW9uYWxFeHBvcnRzKFxuICAgICAgYWNjZXNzb3JTdXBwb3J0Lm1ha2VHZXR0ZXJQcm94eShcbiAgICAgICAgY29tcG9uZW50LFxuICAgICAgICB0aGlzLl93YXRjaGVkUHJvcGVydGllcyxcbiAgICAgICAgdGhpcy5faXNCaW5kaW5nLFxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLmFsbG93ZWRQcm9wTmFtZU1pc21hdGNoZXNcbiAgICAgIClcbiAgICApO1xuICAgIHRyYWNrUHJvcEtleShcbiAgICAgIGNvbXBvbmVudCxcbiAgICAgIChyZXNvbHZlZCkgPT4ge1xuICAgICAgICBpZiAocmVzb2x2ZWQpIHtcbiAgICAgICAgICB0aGlzLl9pbnN0YW5jZVByb3BOYW1lID0gcmVzb2x2ZWQ7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0aGlzLmV4cG9ydHNcbiAgICApO1xuICB9XG4gIGhvc3RDb25uZWN0ZWQoKSB7XG4gICAgdGhpcy5faXNCaW5kaW5nLnZhbHVlID0gZmFsc2U7XG4gIH1cbiAgYXN5bmMgaG9zdExvYWQoKSB7XG4gICAgdGhpcy5yZWFjdGl2ZVV0aWxzID0gYXdhaXQgbG9hZFJlYWN0aXZlVXRpbHMoKTtcbiAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcbiAgICBjb25zdCBwYXJhbWV0ZXJzID0gdGhpcy5fZ2F0aGVyUGFyYW1ldGVycygpO1xuICAgIGNvbnN0IGZpbmFsUGFyYW1ldGVycyA9IHRoaXMuX29wdGlvbnM/LmVkaXRDb25zdHJ1Y3RvclByb3BlcnRpZXM/LmNhbGwoY29tcG9uZW50LCBwYXJhbWV0ZXJzKSA/PyBwYXJhbWV0ZXJzO1xuICAgIGNvbnN0IGF3YWl0ZWRQYXJhbWV0ZXJzID0gZmluYWxQYXJhbWV0ZXJzIGluc3RhbmNlb2YgUHJvbWlzZSA/IGF3YWl0IGZpbmFsUGFyYW1ldGVycyA6IGZpbmFsUGFyYW1ldGVycztcbiAgICBjb25zdCBnZW5lcmljQ29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgIGNvbnN0IGV4aXN0aW5nSW5zdGFuY2UgPSB0eXBlb2YgdGhpcy5faW5zdGFuY2VQcm9wTmFtZSA9PT0gXCJzdHJpbmdcIiA/IGdlbmVyaWNDb21wb25lbnRbdGhpcy5faW5zdGFuY2VQcm9wTmFtZV0gOiB2b2lkIDA7XG4gICAgY29uc3QgaGFzSW5zdGFuY2UgPSBleGlzdGluZ0luc3RhbmNlICE9IG51bGwgJiYgZXhpc3RpbmdJbnN0YW5jZSAhPT0gdGhpcy5leHBvcnRzO1xuICAgIGlmIChoYXNJbnN0YW5jZSkge1xuICAgICAgdGhpcy5faW5zdGFuY2UgPSBleGlzdGluZ0luc3RhbmNlO1xuICAgICAgZXhpc3RpbmdJbnN0YW5jZS5zZXQoYXdhaXRlZFBhcmFtZXRlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pbnN0YW5jZSA9IGF3YWl0IHRoaXMuX2NyZWF0ZUluc3RhbmNlKGF3YWl0ZWRQYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudC5tYW5hZ2VyLmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhY2Nlc3NvclN1cHBvcnQud2F0Y2hDb21wb25lbnRVcGRhdGVzKHRoaXMsIHRoaXMuX2luc3RhbmNlLCB0aGlzLl93YXRjaGVkUHJvcGVydGllcyk7XG4gICAgYWNjZXNzb3JTdXBwb3J0LndhdGNoQWNjZXNzb3JVcGRhdGVzKHRoaXMsIHRoaXMuX2luc3RhbmNlLCB0aGlzLl93YXRjaGVkUHJvcGVydGllcyk7XG4gICAgdGhpcy5leHBvcnRzID0gdGhpcy5faW5zdGFuY2U7XG4gIH1cbiAgX2dhdGhlclBhcmFtZXRlcnMoKSB7XG4gICAgY29uc3QgZGF0YSA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIEFycmF5LmZyb20oXG4gICAgICAgIHRoaXMuX3dhdGNoZWRQcm9wZXJ0aWVzLFxuICAgICAgICAoW3Byb3AsIHByb3BlcnR5XSkgPT4gW3Byb3BlcnR5LCB0aGlzLmNvbXBvbmVudFtwcm9wXV1cbiAgICAgICkuZmlsdGVyKChbLCB2YWx1ZV0pID0+IHZhbHVlICE9PSB2b2lkIDApXG4gICAgKTtcbiAgICBjb25zdCBwcm9wcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBpc0VzcmlJbnRlcm5hbEVudigpID8gZmlsdGVyV2F0Y2hlZFByb3BlcnRpZXM/Lih0aGlzLCBkYXRhKSA/PyBkYXRhIDogZGF0YTtcbiAgICByZXR1cm4gcHJvcHM7XG4gIH1cbiAgYXN5bmMgX2NyZWF0ZUluc3RhbmNlKHBhcmFtZXRlcnMpIHtcbiAgICBpZiAodGhpcy5faXNBY2Nlc3NvckNvbnN0cnVjdG9yKHRoaXMuX2xvYWRBY2Nlc3NvcikpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5fbG9hZEFjY2Vzc29yKHBhcmFtZXRlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5fbG9hZEFjY2Vzc29yKHBhcmFtZXRlcnMpO1xuICAgIH1cbiAgfVxuICBfaXNBY2Nlc3NvckNvbnN0cnVjdG9yKGxvYWRlcikge1xuICAgIHJldHVybiBcInByb3RvdHlwZVwiIGluIGxvYWRlciAmJiBcImRlY2xhcmVkQ2xhc3NcIiBpbiBsb2FkZXIucHJvdG90eXBlO1xuICB9XG4gIGhvc3REZXN0cm95KCkge1xuICAgIGlmICh0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgdGhpcy5faW5zdGFuY2UuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxuICBhc3luYyByZUNyZWF0ZSgpIHtcbiAgICB0aGlzLmhvc3REZXN0cm95KCk7XG4gICAgYXdhaXQgdGhpcy5ob3N0TG9hZCgpO1xuICB9XG59O1xudmFyIHByb3h5ID0gcHJveHlFeHBvcnRzKEFjY2Vzc29yQ29udHJvbGxlcik7XG52YXIgYWNjZXNzb3JTdXBwb3J0ID0ge1xuICBtYWtlR2V0dGVyUHJveHk6IChjb21wb25lbnQsIHdhdGNoZWRQcm9wZXJ0aWVzLCBpc0JpbmRpbmcsIGFsbG93ZWRQcm9wTmFtZU1pc21hdGNoZXMpID0+IG5ldyBQcm94eShcbiAgICB7fSxcbiAgICB7XG4gICAgICAvKlxuICAgICAgICogV2l0aG91dCB0aGlzLCBtYWtlUHJvdmlzaW9uYWxWYWx1ZSgpIHdpbGwgdGhyb3cgb24gYWNjZXNzaW5nXG4gICAgICAgKiBub24tZXhpc3RlbnQgcHJvcFxuICAgICAgICovXG4gICAgICBoYXM6ICh0YXJnZXQsIHByb3ApID0+IHR5cGVvZiBwcm9wID09PSBcInN0cmluZ1wiIHx8IHByb3AgaW4gdGFyZ2V0LFxuICAgICAgZ2V0OiAodGFyZ2V0LCBwcm9wKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wKTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSBcInN5bWJvbFwiIHx8IHByb3AgaW4gUHJvbWlzZS5wcm90b3R5cGUpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFzUHJvcCA9IHByb3AgaW4gdGFyZ2V0O1xuICAgICAgICBjb25zdCBkb0JpbmRpbmcgPSBpc0JpbmRpbmc/LnZhbHVlID8/IHRydWU7XG4gICAgICAgIGlmIChoYXNQcm9wIHx8ICFkb0JpbmRpbmcpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdhdGNoZWRQcm9wZXJ0aWVzLmhhcyhwcm9wKSkge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaXNFc3JpSW50ZXJuYWxFbnYoKSAmJiAhY29tcG9uZW50Lm1hbmFnZXIuaXNMaXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYFRyaWVkIHRvIGJpbmQgXCIke3Byb3AudG9TdHJpbmcoKX1cIiBwcm9wIHR3aWNlLiBUaGlzIG1pZ2h0IGFsc28gaGFwcGVuIGlmIHlvdSBhcmUgdHJ5aW5nIHRvIGFjY2VzcyB0aGUgYWNjZXNzb3IgaW5zdGFuY2UgYmVmb3JlICR7Y29tcG9uZW50Lm1hbmFnZXIuaXNMaXQgPyBcImxvYWRcIiA6IFwiY29tcG9uZW50V2lsbExvYWRcIn0oKWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJhY2tLZXkoXG4gICAgICAgICAgY29tcG9uZW50LFxuICAgICAgICAgIChyZXNvbHZlZCkgPT4ge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBpc0VzcmlJbnRlcm5hbEVudigpKSB7XG4gICAgICAgICAgICAgIGlmIChyZXNvbHZlZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5tYW5hZ2VyLmlzTGl0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgIGBVbmFibGUgdG8gcmVzb2x2ZSB3aGF0IHByb3BlcnR5IGlzIFwiJHtwcm9wLnRvU3RyaW5nKCl9XCIgYmVpbmcgYm91bmQgdG9vLiBDaGVjayBkb2N1bWVudGF0aW9uIGZvciB1c2VBY2Nlc3NvciB0byBlbnN1cmUgcHJvcGVyIHVzYWdlLiBNYWtlIHN1cmUgeW91IGFyZSBub3QgdHJ5aW5nIHRvIGFjY2VzcyB0aGUgYWNjZXNzb3IgaW5zdGFuY2UgYmVmb3JlICR7Y29tcG9uZW50Lm1hbmFnZXIuaXNMaXQgPyBcImxvYWRcIiA6IFwiY29tcG9uZW50V2lsbExvYWRcIn0oKWBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IGlzRmxpcHBpbmdCb29sZWFuID0gcmVzb2x2ZWQua2V5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJkaXNhYmxlXCIpO1xuICAgICAgICAgICAgICBjb25zdCBjb2xsaWRlc1dpdGhOYXRpdmVQcm9wID0gcHJvcCBpbiBIVE1MRWxlbWVudC5wcm90b3R5cGU7XG4gICAgICAgICAgICAgIGNvbnN0IGNvbGxpZGVzV2l0aEN1c3RvbVByb3AgPSBhbGxvd2VkUHJvcE5hbWVNaXNtYXRjaGVzPy5oYXMocHJvcCkgPT09IHRydWU7XG4gICAgICAgICAgICAgIGlmIChyZXNvbHZlZC5rZXkgIT09IHByb3AgJiYgIWNvbGxpZGVzV2l0aE5hdGl2ZVByb3AgJiYgIWNvbGxpZGVzV2l0aEN1c3RvbVByb3AgJiYgIWlzRmxpcHBpbmdCb29sZWFuKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgYFRyaWVkIHRvIGJpbmQgXCIke3Jlc29sdmVkPy5rZXl9XCIgcHJvcGVydHkgdG8gXCIke3Byb3AudG9TdHJpbmcoKX1cIiAtIHByb3BlcnR5IG5hbWVzIG11c3QgbWF0Y2hgXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIXJlc29sdmVkLmlzUmVhY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBjb21wb25lbnQubWFuYWdlci5pc0xpdCA/IGBGb3IgdHdvLXdheSBiaW5kaW5nIHdpdGggQWNjZXNzb3IgdG8gd29yaywgdGhlIHByb3BlcnR5IG9uIHlvdXIgY29tcG9uZW50IG11c3QgaGF2ZSBAcHJvcGVydHkoKSBvciBAc3RhdGUoKSBkZWNvcmF0b3IuIFwiJHtwcm9wLnRvU3RyaW5nKCl9XCIgaGFzIG5laXRoZXJgIDogYEZvciB0d28td2F5IGJpbmRpbmcgd2l0aCBBY2Nlc3NvciB0byB3b3JrLCB0aGUgcHJvcGVydHkgb24geW91ciBjb21wb25lbnQgbXVzdCBoYXZlIEBQcm9wKCkgb3IgQFN0YXRlKCkgZGVjb3JhdG9yLiBcIiR7cHJvcC50b1N0cmluZygpfVwiIGhhcyBuZWl0aGVyYFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXNvbHZlZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIHdhdGNoZWRQcm9wZXJ0aWVzLnNldChyZXNvbHZlZC5rZXksIHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICksXG4gIC8vIFVwZGF0ZSBBY2Nlc3NvciBvbiBjb21wb25lbnQgcHJvcCBjaGFuZ2VcbiAgd2F0Y2hDb21wb25lbnRVcGRhdGVzKGNvbnRyb2xsZXIsIGluc3RhbmNlLCB3YXRjaGVkUHJvcGVydGllcykge1xuICAgIGZ1bmN0aW9uIGdldHRlcihfdmFsdWUsIHByb3BOYW1lKSB7XG4gICAgICBjb25zdCBwcm9wZXJ0eU5hbWUgPSB3YXRjaGVkUHJvcGVydGllcy5nZXQocHJvcE5hbWUpO1xuICAgICAgY29uc3QgdmFsdWUgPSBpbnN0YW5jZVtwcm9wZXJ0eU5hbWVdO1xuICAgICAgY29uc3QgZmxpcEJvb2xlYW4gPSB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiICYmIHByb3BlcnR5TmFtZSAhPT0gcHJvcE5hbWUgJiYgcHJvcE5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcImRpc2FibGVcIik7XG4gICAgICByZXR1cm4gZmxpcEJvb2xlYW4gPyAhdmFsdWUgOiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3Qgc2V0dGVyID0gKG5ld1ZhbHVlLCBfb2xkVmFsdWUsIHByb3BOYW1lKSA9PiB7XG4gICAgICBjb25zdCBwcm9wZXJ0eU5hbWUgPSB3YXRjaGVkUHJvcGVydGllcy5nZXQocHJvcE5hbWUpO1xuICAgICAgY29uc3QgdmFsdWUgPSBpbnN0YW5jZVtwcm9wZXJ0eU5hbWVdO1xuICAgICAgY29uc3QgZmxpcEJvb2xlYW4gPSB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiICYmIHByb3BlcnR5TmFtZSAhPT0gcHJvcE5hbWUgJiYgcHJvcE5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcImRpc2FibGVcIik7XG4gICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBmbGlwQm9vbGVhbiA/ICF2YWx1ZSA6IGNvbXBvbmVudC5tYW5hZ2VyLmlzTGl0ID8gdmFsdWUgPz8gdm9pZCAwIDogdmFsdWU7XG4gICAgICBpZiAoY3VycmVudFZhbHVlID09PSBuZXdWYWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3VmFsdWU7XG4gICAgICB9XG4gICAgICBpbnN0YW5jZVtwcm9wZXJ0eU5hbWVdID0gZmxpcEJvb2xlYW4gPyAhbmV3VmFsdWUgOiBuZXdWYWx1ZTtcbiAgICAgIGNvbnN0IGZpbmFsVmFsdWUgPSBpbnN0YW5jZVtwcm9wZXJ0eU5hbWVdO1xuICAgICAgcmV0dXJuIGZsaXBCb29sZWFuID8gIWZpbmFsVmFsdWUgOiBmaW5hbFZhbHVlO1xuICAgIH07XG4gICAgY29uc3QgY29tcG9uZW50ID0gY29udHJvbGxlci5jb21wb25lbnQ7XG4gICAgY29uc3QgaW50ZXJuYWxzID0gY29tcG9uZW50Lm1hbmFnZXIuaW50ZXJuYWxzO1xuICAgIHdhdGNoZWRQcm9wZXJ0aWVzLmZvckVhY2goKF9wcm9wTmFtZSwgcHJvcGVydHlOYW1lKSA9PiB7XG4gICAgICBpbnRlcm5hbHMuYWNjZXNzb3JHZXR0ZXJbcHJvcGVydHlOYW1lXSA9IGdldHRlcjtcbiAgICAgIGludGVybmFscy5hY2Nlc3NvclNldHRlcltwcm9wZXJ0eU5hbWVdID0gc2V0dGVyO1xuICAgIH0pO1xuICB9LFxuICAvLyBVcGRhdGUgY29tcG9uZW50IG9uIEFjY2Vzc29yIHByb3AgY2hhbmdlXG4gIHdhdGNoQWNjZXNzb3JVcGRhdGVzKGNvbnRyb2xsZXIsIGluc3RhbmNlLCB3YXRjaGVkUHJvcGVydGllcykge1xuICAgIGNvbnN0IHsgY29tcG9uZW50IH0gPSBjb250cm9sbGVyO1xuICAgIGNvbnN0IGdlbmVyaWNDb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgY29uc3QgZ2VuZXJpY0luc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgY29uc3QgcmVhZG9ubHlQcm9wcyA9IGZpbmRSZWFkT25seUFjY2Vzc29yUHJvcHMoaW5zdGFuY2UpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaXNFc3JpSW50ZXJuYWxFbnYoKSkge1xuICAgICAgc2V0UmVhZG9ubHlQcm9wcz8uKGNvbnRyb2xsZXIsIHJlYWRvbmx5UHJvcHMpO1xuICAgIH1cbiAgICBieXBhc3NHZXR0ZXIoXG4gICAgICAoKSA9PiAoXG4gICAgICAgIC8vIENhcmVmdWw6IE1hcCdzIGZvckVhY2ggY2FsbGJhY2sgYXJndW1lbnRzIGFyZSAodmFsdWUsIGtleSksIG5vdCAoa2V5LCB2YWx1ZSlcbiAgICAgICAgd2F0Y2hlZFByb3BlcnRpZXMuZm9yRWFjaCgocHJvcGVydHlOYW1lLCBwcm9wTmFtZSkgPT4ge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaXNFc3JpSW50ZXJuYWxFbnYoKSAmJiAhKHByb3BlcnR5TmFtZSBpbiBpbnN0YW5jZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke3Byb3BlcnR5TmFtZX1cIiBkb2VzIG5vdCBleGlzdCBvbiB0aGUgYWNjZXNzb3IgaW5zdGFuY2VgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlYWRvbmx5UHJvcHMuaGFzKHByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZG9tVmFsdWUgPSBnZW5lcmljQ29tcG9uZW50W3Byb3BOYW1lXTtcbiAgICAgICAgICBsZXQgbW9kZWxWYWx1ZSA9IGdlbmVyaWNJbnN0YW5jZVtwcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgIGlmIChjb21wb25lbnQubWFuYWdlci5pc0xpdCkge1xuICAgICAgICAgICAgbW9kZWxWYWx1ZSA/PyAobW9kZWxWYWx1ZSA9IHZvaWQgMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGZsaXBCb29sZWFuID0gdHlwZW9mIGRvbVZhbHVlID09PSBcImJvb2xlYW5cIiAmJiBwcm9wZXJ0eU5hbWUgIT09IHByb3BOYW1lICYmIHByb3BOYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJkaXNhYmxlXCIpO1xuICAgICAgICAgIGNvbnN0IHJlc29sdmVkRG9tVmFsdWUgPSBmbGlwQm9vbGVhbiA/ICFkb21WYWx1ZSA6IGRvbVZhbHVlO1xuICAgICAgICAgIGlmIChyZXNvbHZlZERvbVZhbHVlICE9IG51bGwgJiYgbW9kZWxWYWx1ZSAhPT0gcmVzb2x2ZWREb21WYWx1ZSkge1xuICAgICAgICAgICAgZ2VuZXJpY0luc3RhbmNlW3Byb3BlcnR5TmFtZV0gPSByZXNvbHZlZERvbVZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIClcbiAgICApO1xuICAgIGNvbnRyb2xsZXIub25MaWZlY3ljbGUoKCkgPT4ge1xuICAgICAgaWYgKGluc3RhbmNlLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShcbiAgICAgICAgd2F0Y2hlZFByb3BlcnRpZXMsXG4gICAgICAgIChbcHJvcE5hbWUsIHByb3BlcnR5TmFtZV0pID0+IGNvbnRyb2xsZXIucmVhY3RpdmVVdGlscy53YXRjaChcbiAgICAgICAgICAoKSA9PiBnZW5lcmljSW5zdGFuY2VbcHJvcGVydHlOYW1lXSxcbiAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IGdlbmVyaWNJbnN0YW5jZVtwcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgICAgY29uc3QgZmxpcEJvb2xlYW4gPSB0eXBlb2YgbmV3VmFsdWUgPT09IFwiYm9vbGVhblwiICYmIHByb3BlcnR5TmFtZSAhPT0gcHJvcE5hbWUgJiYgcHJvcE5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcImRpc2FibGVcIik7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZE5ld1ZhbHVlID0gZmxpcEJvb2xlYW4gPyAhbmV3VmFsdWUgOiBuZXdWYWx1ZTtcbiAgICAgICAgICAgIGJ5cGFzc1NldHRlcigoKSA9PiB7XG4gICAgICAgICAgICAgIGdlbmVyaWNDb21wb25lbnRbcHJvcE5hbWVdID0gcmVzb2x2ZWROZXdWYWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgeyBpbml0aWFsOiB0cnVlIH1cbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSxcbiAgLy8gUkVGQUNUT1I6IHJlbW92ZSB0aGlzIG9uY2UgU3RlbmNpbCBpcyBubyBsb25nZXIgc3VwcG9ydGVkXG4gIHJlRW1pdEFjY2Vzc29yRXZlbnRzKGNvbnRyb2xsZXIsIGluc3RhbmNlLCByZWFjdGl2ZVV0aWxzMiwgcHJlZml4KSB7XG4gICAgY29uc3QgaXNFdmVudGVkID0gXCJvblwiIGluIGluc3RhbmNlICYmIHR5cGVvZiBpbnN0YW5jZS5vbiA9PT0gXCJmdW5jdGlvblwiO1xuICAgIGlmICghaXNFdmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRvTGlzdGVuID0gT2JqZWN0LmVudHJpZXMoY29udHJvbGxlci5jb21wb25lbnQpLm1hcCgoW2tleSwgdW5rbm93bl0pID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdW5rbm93bjtcbiAgICAgIGlmICgha2V5LnN0YXJ0c1dpdGgocHJlZml4KSB8fCBrZXkgPT09IHByZWZpeCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT09IG51bGwgfHwgIShcImVtaXRcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLmVtaXQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgICAgY29uc3QgZW1pdCA9IHZhbHVlLmVtaXQ7XG4gICAgICBjb25zdCB0cmltbWVkRXZlbnROYW1lID0ga2V5LnNsaWNlKHByZWZpeC5sZW5ndGgpO1xuICAgICAgY29uc3QgY2FtZWxDYXNlRXZlbnROYW1lID0gY2FtZWxUb0tlYmFiKHRyaW1tZWRFdmVudE5hbWUpO1xuICAgICAgY29uc3QgZXZlbnROYW1lID0gY2FtZWxDYXNlRXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICByZXR1cm4gW2V2ZW50TmFtZSwgZW1pdF07XG4gICAgfSkuZmlsdGVyKGlzTm90VW5kZWZpbmVkKTtcbiAgICBpZiAodG9MaXN0ZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGV2ZW50VGFyZ2V0ID0gaW5zdGFuY2U7XG4gICAgY29uc3QgZ2V0RXZlbnRUYXJnZXQgPSAoKSA9PiBldmVudFRhcmdldDtcbiAgICBjb250cm9sbGVyLm9uTGlmZWN5Y2xlKCgpID0+IHtcbiAgICAgIGlmIChpbnN0YW5jZS5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRvTGlzdGVuLm1hcCgoW2V2ZW50TmFtZSwgZW1pdF0pID0+IHJlYWN0aXZlVXRpbHMyLm9uKGdldEV2ZW50VGFyZ2V0LCBldmVudE5hbWUsIGVtaXQpKTtcbiAgICB9KTtcbiAgfSxcbiAgYXN5bmMgcmVDcmVhdGUoaW5zdGFuY2UsIGNvbXBvbmVudCkge1xuICAgIGNvbnN0IGFjY2Vzc29yQ29udHJvbGxlciA9IGNvbXBvbmVudC5tYW5hZ2VyLnVzZVJlZlN5bmMoaW5zdGFuY2UpO1xuICAgIGlmIChhY2Nlc3NvckNvbnRyb2xsZXIgPT09IHZvaWQgMCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiVW5hYmxlIHRvIHJlc29sdmUgdGhlIHVzZUFjY2Vzc29yIGNvbnRyb2xsZXIgZnJvbSB0aGUgcHJvdmlkZWQgdmFsdWVcIik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGF3YWl0IGFjY2Vzc29yQ29udHJvbGxlci5yZUNyZWF0ZSgpO1xuICB9XG59O1xuZnVuY3Rpb24gZmluZFJlYWRPbmx5QWNjZXNzb3JQcm9wcyhpbnN0YW5jZSkge1xuICBjb25zdCBhY2Nlc3NvciA9IGluc3RhbmNlO1xuICBjb25zdCBwcm9wZXJ0aWVzID0gT2JqZWN0LmVudHJpZXMoYWNjZXNzb3IuX19hY2Nlc3Nvcl9fPy5tZXRhZGF0YSA/PyB7fSk7XG4gIHJldHVybiBuZXcgU2V0KFxuICAgIHByb3BlcnRpZXMuZmlsdGVyKChbX3Byb3BlcnR5LCBkZXNjcmlwdG9yXSkgPT4gZGVzY3JpcHRvcj8ucmVhZE9ubHkgPT09IHRydWUpLm1hcCgoW3Byb3BlcnR5XSkgPT4gcHJvcGVydHkpXG4gICk7XG59XG52YXIgc2V0UmVhZG9ubHlQcm9wcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBpc0VzcmlJbnRlcm5hbEVudigpID8gKGNvbnRyb2xsZXIsIHByb3BlcnRpZXMpID0+IHtcbiAgZGV2T25seVNldFBlcnNpc3RlbnRDb250cm9sbGVyRGF0YT8uKGNvbnRyb2xsZXIsIHByb3BlcnRpZXMpO1xufSA6IHZvaWQgMDtcbnZhciBmaWx0ZXJXYXRjaGVkUHJvcGVydGllcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBpc0VzcmlJbnRlcm5hbEVudigpID8gKGNvbnRyb2xsZXIsIGRhdGEpID0+IHtcbiAgY29uc3QgcmVhZG9ubHlQcm9wZXJ0aWVzID0gZGV2T25seUdldFBlcnNpc3RlbnRDb250cm9sbGVyRGF0YT8uKGNvbnRyb2xsZXIpO1xuICBpZiAocmVhZG9ubHlQcm9wZXJ0aWVzIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhkYXRhKS5maWx0ZXIoKFtrZXldKSA9PiAhcmVhZG9ubHlQcm9wZXJ0aWVzLmhhcyhrZXkpKSk7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59IDogdm9pZCAwO1xuXG4vLyBzcmMvYWNjZXNzb3IvcmVFbWl0RXZlbnQudHNcbmltcG9ydCB7IGlzRXNyaUludGVybmFsRW52IGFzIGlzRXNyaUludGVybmFsRW52MiB9IGZyb20gXCJAYXJjZ2lzL2NvbXBvbmVudHMtdXRpbHNcIjtcbmZ1bmN0aW9uIHJlRW1pdEV2ZW50KGdldEV2ZW50ZWRBY2Nlc3NvciwgZXZlbnROYW1lKSB7XG4gIGNvbnN0IGNvbXBvbmVudCA9IHJldHJpZXZlQ29tcG9uZW50KCk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaXNFc3JpSW50ZXJuYWxFbnYyKCkgJiYgIWNvbXBvbmVudC5tYW5hZ2VyLmlzTGl0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJyZUVtaXRFdmVudCBpcyBvbmx5IHN1cHBvcnRlZCBpbiBMdW1pbmEgY29tcG9uZW50cy4gQ29uc3VsdCBkb2N1bWVudGF0aW9uIGZvciBlcXVpdmFsZW50IFN0ZW5jaWwgcGF0dGVybi5cIlxuICAgICk7XG4gIH1cbiAgY29uc3QgbWFuYWdlciA9IGNvbXBvbmVudC5tYW5hZ2VyO1xuICBjb25zdCByZWFjdGl2ZVV0aWxzMiA9IGxvYWRSZWFjdGl2ZVV0aWxzKCk7XG4gIG1hbmFnZXIub25Mb2FkZWQoKCkgPT4ge1xuICAgIHZvaWQgcmVhY3RpdmVVdGlsczIudGhlbihcbiAgICAgIChyZWFjdGl2ZVV0aWxzMykgPT4gbWFuYWdlci5vbkxpZmVjeWNsZSgoKSA9PiByZWFjdGl2ZVV0aWxzMy5vbihnZXRFdmVudGVkQWNjZXNzb3IsIGV2ZW50TmFtZSwgZW1pdHRlci5lbWl0KSlcbiAgICApO1xuICB9KTtcbiAgY29uc3QgZW1pdHRlciA9IGNvbXBvbmVudC5jb25zdHJ1Y3Rvci4kY3JlYXRlRXZlbnQoKTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBpc0VzcmlJbnRlcm5hbEVudjIoKSkge1xuICAgIGlmICh0eXBlb2YgZW1pdHRlciAhPT0gXCJvYmplY3RcIiB8fCBlbWl0dGVyID09PSBudWxsIHx8ICEoXCJlbWl0XCIgaW4gZW1pdHRlcikgfHwgdHlwZW9mIGVtaXR0ZXIuZW1pdCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIHRvIGZpbmQgJGNyZWF0ZUV2ZW50IHN0YXRpYyBwcm9wZXJ0eSBvbiBMdW1pbmEncyBMaXRFbGVtZW50YCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbWl0dGVyO1xufVxuZXhwb3J0IHtcbiAgQWNjZXNzb3JDb250cm9sbGVyLFxuICBhY2Nlc3NvclN1cHBvcnQsXG4gIG1ha2VBY2Nlc3NvckNvbnRyb2xsZXIsXG4gIHJlRW1pdEV2ZW50XG59O1xuIiwiLyohIEFsbCBtYXRlcmlhbCBjb3B5cmlnaHQgRXNyaSwgQWxsIFJpZ2h0cyBSZXNlcnZlZCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG5TZWUgaHR0cHM6Ly9qcy5hcmNnaXMuY29tLzQuMzIvZXNyaS9jb3B5cmlnaHQudHh0IGZvciBkZXRhaWxzLlxudjQuMzIuMSAqL1xuZnVuY3Rpb24gUChlLCBpKSB7XG4gIEFycmF5LmlzQXJyYXkoaSkgPyBlLl93YXRjaEhhbmRsZXMgPSBbLi4uZS5fd2F0Y2hIYW5kbGVzLCAuLi5pXSA6IGUuX3dhdGNoSGFuZGxlcy5wdXNoKGkpO1xufVxuZnVuY3Rpb24gcChlKSB7XG4gIGUuZWwuY2hpbGRFbGVtICYmIChlLmVsLmNoaWxkRWxlbS5vd25lZEJ5ID0gZS5lbCk7XG4gIGNvbnN0IGkgPSBoKGUpO1xuICBpZiAoIWkpIHtcbiAgICBjb25zdCB0ID0geShlLnJlZmVyZW5jZUVsZW1lbnQpO1xuICAgIGlmICghdCkge1xuICAgICAgZyhlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGYodCwgZSwgITApLCB0O1xuICB9XG4gIHJldHVybiB3KGksIGUuZWwucGFyZW50KSB8fCAoZS5lbC5wYXJlbnQgPSBpLCBpLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJhcmNnaXMtZXhwYW5kXCIgPyB2KGksIGUpIDogaS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiYXJjZ2lzLXBsYWNlbWVudFwiID8gQyhpLCBlKSA6IGYoaSwgZSwgITEpKSwgaTtcbn1cbmZ1bmN0aW9uIGgoeyBlbDogZSB9KSB7XG4gIGZvciAobGV0IGkgPSBlLnBhcmVudEVsZW1lbnQ7IGk7IGkgPSBpPy5wYXJlbnRFbGVtZW50ID8/IG51bGwpIHtcbiAgICBpZiAoYy5oYXMoaS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpKVxuICAgICAgcmV0dXJuIGk7XG4gICAgaWYgKFwib3duZWRCeVwiIGluIGkgJiYgaS5vd25lZEJ5IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgYy5oYXMoaS5vd25lZEJ5LnRhZ05hbWUudG9Mb3dlckNhc2UoKSkpXG4gICAgICByZXR1cm4gaS5vd25lZEJ5O1xuICB9XG59XG5jb25zdCBjID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcImFyY2dpcy1tYXBcIixcbiAgXCJhcmNnaXMtc2NlbmVcIixcbiAgXCJhcmNnaXMtbGluay1jaGFydFwiLFxuICBcImFyY2dpcy1leHBhbmRcIixcbiAgXCJhcmNnaXMtcGxhY2VtZW50XCJcbl0pO1xuZnVuY3Rpb24gdyhlLCBpKSB7XG4gIGlmIChlICE9PSBpKVxuICAgIHJldHVybiAhMTtcbiAgY29uc3QgdCA9IGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gdCA9PT0gXCJhcmNnaXMtZXhwYW5kXCIgfHwgdCA9PT0gXCJhcmNnaXMtcGxhY2VtZW50XCI7XG59XG5mdW5jdGlvbiBsKGUsIGksIHQgPSBcImFyY2dpc1JlYWR5XCIpIHtcbiAgY29uc3QgciA9IGU7XG4gIGlmICh0eXBlb2Ygci52aWV3Py5yZWFkeSA9PSBcImJvb2xlYW5cIilcbiAgICBpKHIudmlldyk7XG4gIGVsc2Uge1xuICAgIGxldCBzID0gZnVuY3Rpb24oZCkge1xuICAgICAgZC50YXJnZXQgPT09IGUgJiYgKGwoZSwgaSwgdCksIGUucmVtb3ZlRXZlbnRMaXN0ZW5lcih0LCBzKSk7XG4gICAgfTtcbiAgICBlLmFkZEV2ZW50TGlzdGVuZXIodCwgcyk7XG4gIH1cbn1cbmNvbnN0IHYgPSAoZSwgaSkgPT4gbChlLCAodCkgPT4ge1xuICBpLmVsLmNoaWxkRWxlbSAmJiBlLmNvbnRlbnQgIT0gbnVsbCAmJiBlLmNvbnRlbnQuYXBwZW5kKGkuZWwuY2hpbGRFbGVtKSwgZS5leHBhbmRJY29uID0gaS5pY29uIHx8IGkud2lkZ2V0Py5pY29uIHx8IGUuZXhwYW5kSWNvbiwgaS5wb3NpdGlvbiA9IGUucG9zaXRpb24sIGkuZWwudmlldyA9IHQ7XG59KSwgQyA9IChlLCBpKSA9PiBsKGUsICh0KSA9PiB7XG4gIGkuZWwuY2hpbGRFbGVtICYmIGkuZWwuYXBwZW5kKGkuZWwuY2hpbGRFbGVtKSwgaS5wb3NpdGlvbiA9IGUucG9zaXRpb24sIGkuZWwudmlldyA9IHQ7XG59KSwgZiA9IChlLCBpLCB0KSA9PiBsKFxuICBlLFxuICAocikgPT4ge1xuICAgIHQgPyBnKGkpIDogaS5lbC5jaGlsZEVsZW0gJiYgRShlLCBpKSwgaS5lbC52aWV3ID0gcjtcbiAgfSxcbiAgXCJhcmNnaXNWaWV3UmVhZHlDaGFuZ2VcIlxuKTtcbmZ1bmN0aW9uIEUoZSwgaSkge1xuICBjb25zdCB0ID0gaS5lbC5jaGlsZEVsZW0gPz8gaS5lbCwgciA9IFsuLi5lLmNoaWxkcmVuXSwgcyA9IHt9O1xuICBmb3IgKGNvbnN0IGEgb2Ygcikge1xuICAgIGNvbnN0IG4gPSBhLmdldEF0dHJpYnV0ZShcInBvc2l0aW9uXCIpID8/IFwibWFudWFsXCI7XG4gICAgc1tuXSA/Pz0gW10sIHNbbl0ucHVzaCh7IGNoaWxkOiBhLCBwb3NpdGlvbjogbiwgaW5kZXg6IHIuaW5kZXhPZihhKSB9KTtcbiAgfVxuICBjb25zdCBkID0gc1tpLnBvc2l0aW9uID8/IFwibWFudWFsXCJdPy5maW5kSW5kZXgoKHsgY2hpbGQ6IGEgfSkgPT4gYSA9PT0gaS5lbCksIG8gPSBlLnZpZXcudWk7XG4gIG8ucmVtb3ZlKHQpLCBvLmFkZCh0LCB7IHBvc2l0aW9uOiBpLnBvc2l0aW9uLCBpbmRleDogZCB9KTtcbn1cbmZ1bmN0aW9uIEwoZSkge1xuICBsZXQgaSA9ICExLCB0ID0gZS5lbC52aWV3O1xuICBjb25zdCByID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QuZ2V0UHJvdG90eXBlT2YoZS5lbCksIFwidmlld1wiKSA/PyB7XG4gICAgZ2V0OiAoKSA9PiB0LFxuICAgIHNldDogKHMpID0+IHQgPSBzXG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLmVsLCBcInZpZXdcIiwge1xuICAgIGdldDogci5nZXQuYmluZChlLmVsKSxcbiAgICBzZXQ6IChzKSA9PiB7XG4gICAgICByLnNldC5jYWxsKGUuZWwsIHMpLCBzICYmICFpICYmIChpID0gITAsIGUuYXJjZ2lzUmVhZHkuZW1pdCgpKTtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgZW51bWVyYWJsZTogITBcbiAgfSksIHQgJiYgKGUuZWwudmlldyA9IHQpO1xufVxuZnVuY3Rpb24geChlKSB7XG4gIHJldHVybiBlID09IG51bGwgfHwgZSA9PT0gXCJcIjtcbn1cbmZ1bmN0aW9uIEgoZSwgaSkge1xuICByZXR1cm4gaSAhPSBudWxsICYmIGU/LnBvc2l0aW9uID09PSBpLnBvc2l0aW9uICYmIGU/LmhlYWRpbmcgPT09IGkuaGVhZGluZyAmJiBlPy50aWx0ID09PSBpLnRpbHQgJiYgZT8uZm92ID09PSBpLmZvdjtcbn1cbmZ1bmN0aW9uIE4oZSwgaSkge1xuICByZXR1cm4gaSA9PT0gdm9pZCAwIHx8IGU/LnRhcmdldEdlb21ldHJ5ICE9PSBpPy50YXJnZXRHZW9tZXRyeSB8fCBlPy5yb3RhdGlvbiAhPT0gaT8ucm90YXRpb24gfHwgZT8uc2NhbGUgIT09IGk/LnNjYWxlO1xufVxuZnVuY3Rpb24gTyhlLCBpKSB7XG4gIHJldHVybiB1KGk/LmNlbnRlciwgZSk7XG59XG5mdW5jdGlvbiB1KGUsIGkpIHtcbiAgaWYgKHR5cGVvZiBpID09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIHUoZSwgaS5zcGxpdChcIixcIikubWFwKE51bWJlcikpO1xuICBpZiAoIWUpXG4gICAgcmV0dXJuIGk7XG4gIGlmIChBcnJheS5pc0FycmF5KGkpKSB7XG4gICAgY29uc3QgdCA9IGlbMF0sIHIgPSBpWzFdLCBzID0gaS5sZW5ndGggPiAyID8gaVsyXSA6IHZvaWQgMDtcbiAgICBpZiAodCAhPT0gZS5sb25naXR1ZGUgfHwgciAhPT0gZS5sYXRpdHVkZSB8fCBzICE9PSBlLnopXG4gICAgICByZXR1cm4gaTtcbiAgfSBlbHNlIGlmIChpICYmICFlPy5lcXVhbHMoaSkpXG4gICAgcmV0dXJuIGk7XG59XG5hc3luYyBmdW5jdGlvbiBTKGUsIGkpIHtcbiAgaSAhPSBudWxsICYmICh0eXBlb2YgaSA9PSBcInN0cmluZ1wiID8gZS5lbC52aWV3ID0gYXdhaXQgYihpKSA6IGUud2lkZ2V0ICYmIChlLmVsLnZpZXcgPSBpLnZpZXcpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGIoZSkge1xuICBjb25zdCBpID0geShlKTtcbiAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKCh0KSA9PiB7XG4gICAgdHlwZW9mIGk/LnZpZXc/LnJlYWR5ID09IFwiYm9vbGVhblwiID8gdChpLnZpZXcpIDogaSAmJiBpLmFkZEV2ZW50TGlzdGVuZXIoXCJhcmNnaXNWaWV3UmVhZHlDaGFuZ2VcIiwgKCkgPT4gdChpLnZpZXcpLCB7IG9uY2U6ICEwIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGcoZSkge1xuICBlLmVsLmNoaWxkRWxlbSAmJiAoZS5lbC5zaGFkb3dSb290ID8/IGUuZWwpLmFwcGVuZChlLmVsLmNoaWxkRWxlbSk7XG59XG5mdW5jdGlvbiB5KGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBlICE9IFwic3RyaW5nXCIgPyBlID8/IHZvaWQgMCA6IChlLmluY2x1ZGVzKFwiI1wiKSB8fCBlLmluY2x1ZGVzKFwiLlwiKSB8fCBlLmluY2x1ZGVzKFwiW1wiKSA/IHZvaWQgMCA6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYCMke2V9YCkpID8/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZSkgPz8gdm9pZCAwO1xufVxuZXhwb3J0IHtcbiAgcCBhcyBhLFxuICBQIGFzIGIsXG4gIEggYXMgYyxcbiAgTCBhcyBkLFxuICBPIGFzIGUsXG4gIHggYXMgZixcbiAgTiBhcyBpLFxuICB1IGFzIHAsXG4gIFMgYXMgclxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==